* Install packages

  Package list:

  - ace-jump-mode :: Quick jump to words
  - ace-window :: Quick jump to other windows
  - anzu :: Show number of matches in modeline while searching
  - diminish :: Don't show some minor modes in mode line
  - evil :: Vim emulation
  - evil-leader :: Have a key and then another to execute stuff
  - evil-args :: Kan välja argument som en enhet i evil
  - evil-nerd-commenter :: Kommentera saker i evil lättare
  - evil-surround-mode :: Ta bort saker runt ord, typ taggar eller ""
  - expand-region :: Select logical units, then expand
  - flycheck :: On the fly syntax checking
  - htmlize :: Convert buffer to html
  - jedi :: Completion for Python
  - neotree :: Få upp ett filträd
  - skewer-mode :: Skicka saker från emacs till webläsaren
  - smex :: Ido for M-x
  - smartparens :: Like paredit
  - rainbow-delimeters :: Make () and such different colors
  - undo-tree :: Better undo
  - yascroll :: Show scrollbar in fringe
  - emmet :: Write html more easy
  - rainbow-mode :: Show colors in buffer when writing e.g. #ffa3f2
  - yafolding :: Fold code blocks

  #+begin_src emacs-lisp
    (require 'package)
    (package-initialize)

    (add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/"))
    (add-to-list 'package-archives '("SC"   . "http://joseito.republika.pl/sunrise-commander/"))

    (defvar my-packages '(ace-jump-mode ace-window
                          anzu
                          auctex
                          bookmark+
                          deft
                          dired+ dired-details+
                          diminish
                          coffee-mode
                          angular-snippets
                          evil evil-leader evil-args evil-nerd-commenter evil-surround
                          expand-region
                          flycheck
                          helm helm-projectile
                          jedi
                          js2-mode
                          htmlize
                          ido-vertical-mode flx-ido
                          key-chord
                          lua-mode
                          markdown-mode
                          magit
                          multiple-cursors
                          neotree
                          openwith
                          ox-reveal
                          projectile
                          pydoc-info
                          skewer-mode
                          smex
                          smartparens
                          slime rainbow-delimiters
                          sunrise-commander
                          undo-tree
                          web-mode
                          yafolding
                          yascroll
                          yasnippet
                          zenburn-theme
                          emmet-mode rainbow-mode)
      "List of packages to install at launch")

    (if system-type 'gnu/linux
      (setq my-packages (append my-packages '(ac-nrepl nrepl clojure-mode clojure-cheatsheet))))

    (defun my-missing-packages ()
      (let (missing-packages)
        (dolist (package my-packages (reverse missing-packages))
          (or (package-installed-p package)
    (push package missing-packages)))))

    (defun ensure-my-packages ()
      (let ((missing (my-missing-packages)))
        (when missing
          ;; Check for new packages (package versions)
          (package-refresh-contents)
          ;; Install the missing packages
          (mapc (lambda (package)
    (when (not (package-installed-p package))
    (package-install package)))
    missing)
          ;; Close the compilation log.
          (let ((compile-window (get-buffer-window "*Compile-Log*")))
    (if compile-window
    (delete-window compile-window))))))

    (ensure-my-packages)
  #+end_src

* Emacs init

  #+begin_src emacs-lisp
    (setq frame-title-format '("emacs"))
    (set-language-environment "English")
    (if system-type 'gnu/linux
      (set-frame-font "Terminus-10"))

    (let ((default-directory "~/.emacs.d/plugins/"))
      (normal-top-level-add-to-load-path '("" "ledger")))

    (load "ledger-mode")

    (package-initialize)
    (load-theme 'zenburn t)

    (setq make-backup-files t)
    (setq version-control t
          backup-by-copying t
          delete-old-versions t
          kept-old-versions 6
          kept-new-versions 9)
    (setq backup-directory-alist (quote ((".*" . "~/.emacs.d/backups/"))))
    (setq auto-save-file-name-transforms
          `((".*" ,temporary-file-directory t)))
  #+end_src

* Personal info

  #+begin_src emacs-lisp
    (setq user-mail-address "sjostrand.erik@gmail.com")
    (setq user-full-name "Erik Sjöstrand")
  #+end_src

* General configuration

  First we tidy up Emacs and get rid of stuff we do not want in the
  GUI. We also add GUI things we actually want, like Anzu and yascroll.

  #+begin_src emacs-lisp
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (column-number-mode t)
  (blink-cursor-mode 0)
  (show-smartparens-global-mode +1)
  (setq ring-bell-function 'ignore)
  (setq inhibit-startup-screen 1)
  (fset 'yes-or-no-p 'y-or-n-p)
  (global-hl-line-mode +1)
  (scroll-bar-mode -1)
  (require 'yascroll)
  (global-yascroll-bar-mode 1)
  ;; make the fringe (gutter) smaller
  ;; the argument is a width in pixels (the default is 8)
  (if (fboundp 'fringe-mode)
      (fringe-mode 4))

  ;; diminish keeps the modeline tidy
  (require 'diminish)
  
  (require 'anzu)
  (global-anzu-mode +1)
  (diminish 'anzu-mode)

  ;; enable winner-mode to manage window configurations
  ;; (winner-mode +1)
  #+end_src

  The code below make Emacs more to my liking, regarding tabs,
  deletion of selections, scrolling and coding-systems.

  #+begin_src emacs-lisp
  (add-hook 'after-init-hook 'yas-global-mode)
  ;; (global-set-key (kbd "C-x C-b") 'ibuffer)
  
  (setq-default indent-tabs-mode nil)
  (pending-delete-mode 1)
      
  (setq
   scroll-margin 5
   scroll-conservatively 100000
   scroll-preserve-screen-position 1)

  (setq sentence-end-double-space nil)
    
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  
  (global-set-key [remap goto-line] 'goto-line-with-feedback)

  ;; sensible undo
  (global-undo-tree-mode)
  (diminish 'undo-tree-mode)  
  #+end_src

  Some general functions:

  #+begin_src emacs-lisp
    (defun ess/new-leftframe ()
      "Creates a new frame with fontsize suitable for the left screen"
      (interactive)
      (set-frame-font "Terminus-18" nil (list (make-frame))))
  #+end_src

** History and save files

   #+begin_src emacs-lisp
  ;; saveplace remembers your location in a file when saving files
  (require 'saveplace)
  (setq save-place-file (expand-file-name "saveplace" user-emacs-directory))
  ;; activate it for all buffers
  (setq-default save-place t)
  
  ;; savehist keeps track of some history
  (require 'savehist)
  (setq savehist-additional-variables
        ;; search entries
        '(search ring regexp-search-ring)
        ;; save every minute
        savehist-autosave-interval 60
        ;; keep the home clean
        savehist-file (expand-file-name "savehist" user-emacs-directory))
  (savehist-mode +1)
  
  ;; save recent files
  (require 'recentf)
  (setq recentf-save-file (expand-file-name "recentf" user-emacs-directory)
        recentf-max-saved-items 500
        recentf-max-menu-items 15)
  (recentf-mode +1)
  
  (global-auto-revert-mode t)
   #+end_src

** Ido

#+begin_src emacs-lisp
  ;; (require 'ido)
  ;; (require 'ido-vertical-mode)
  ;; (ido-mode 1)
  ;; (ido-vertical-mode 1)
  ;; (ido-everywhere t)
  ;; (setq ido-enable-flex-matching t)
  ;; (setq smex-save-file "~/.emacs.d/.smex-items")
#+end_src

* Helm

  Tab is used to execute default action, C-z is used to select action. C-c h is the helm prefix.

  #+begin_src emacs-lisp
    (require 'helm-config)
    (global-set-key (kbd "C-c h") 'helm-command-prefix)
    (global-unset-key (kbd "C-x c"))

    (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
    (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
    (define-key helm-map (kbd "C-z") 'helm-select-action)

    (when (executable-find "curl")
      (setq helm-google-suggest-use-curl-p t))

    (setq helm-quick-update t
          helm-split-window-in-side-p t
          helm-buffers-fuzzy-matching t
          helm-move-to-line-cycle-in-source t
          helm-ff-search-library-in-sexp t
          helm-scroll-amount 8
          helm-ff-file-name-history-use-recentf t)

    (helm-mode 1)
    (helm-projectile-on)
  #+end_src

  Some new keybindings

  #+begin_src emacs-lisp
    (global-set-key (kbd "M-x") 'helm-M-x)
    (global-set-key (kbd "M-y") 'helm-show-kill-ring)
    (global-set-key (kbd "C-x b") 'helm-mini)
    (global-set-key (kbd "C-x C-f") 'helm-find-files)

    (when (executable-find "ack-grep")
      (setq helm-grep-default-command "ack-grep -Hn --no-group --no-color %e %p %f"
            helm-grep-default-recurse-command "ack-grep -H --no-group --no-color %e %p %f"))

    (global-set-key (kbd "C-c h o") 'helm-occur)
    (global-set-key (kbd "C-h SPC") 'helm-all-mark-rings)
    (global-set-key (kbd "C-c h g") 'helm-google-suggest)
  #+end_src

* Text editing

  Enables stuff which is disabled by default.

  #+begin_src emacs-lisp
    (put 'narrow-to-region 'disabled nil)
    (put 'narrow-to-page 'disabled nil)
    (put 'narrow-to-defun 'disabled nil)
    (put 'upcase-region 'disabled nil)
    (put 'downcase-region 'disabled nil)
  #+end_src

  Eval and replace

  #+begin_src emacs-lisp
    (defun eval-and-replace ()
      "Replace the preceding sexp with its value."
      (interactive)
      (backward-kill-sexp)
      (condition-case nil
          (prin1 (eval (read (current-kill 0)))
                 (current-buffer))
        (error (message "Invalid expression")
               (insert (current-kill 0)))))
  #+end_src

  An idea of using the dash key to insert underscore or regular dash depending on the context.

  #+begin_src emacs-lisp
    
    (defun smart-dash ()
      "Inserts an underscore by default, but a dash if preceeded by number or underscore"
      (if (equal (string (char-before)) "_") 
          (progn (delete-backward-char 1) (insert "-"))
          (if (member (char-before) '(?0 ?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9))
              (insert "-")
            (insert "_"))))
  #+end_src
** Deprecated

(defun compact-uncompact-block ()
  "Remove or add line ending chars on current paragraph.
This command is similar to a toggle of `fill-paragraph'.
When there is a text selection, act on the region."
  (interactive)

  ;; This command symbol has a property "'stateIsCompact-p".
  (let (currentStateIsCompact (bigFillColumnVal 90002000) (deactivate-mark nil))
    ;; 90002000 is just random. you can use `most-positive-fixnum'

    (save-excursion
      ;; Determine whether the text is currently compact.
      (setq currentStateIsCompact
            (if (eq last-command this-command)
                (get this-command 'stateIsCompact-p)
              (if (> (- (line-end-position) (line-beginning-position)) fill-column) t nil) ) )

      (if (region-active-p)
          (if currentStateIsCompact
              (fill-region (region-beginning) (region-end))
            (let ((fill-column bigFillColumnVal))
              (fill-region (region-beginning) (region-end))) )
        (if currentStateIsCompact
            (fill-paragraph nil)
          (let ((fill-column bigFillColumnVal))
            (fill-paragraph nil)) ) )

      (put this-command 'stateIsCompact-p (if currentStateIsCompact nil t)) ) ) )

(global-set-key "\M-q" 'compact-uncompact-block)

;; = smart open and line, join line and line beginning

(defun smart-open-line ()
  "Insert an empty line after the current line.
   Position the cursor at its beginning, according to the current mode."
  (interactive)
  (move-end-of-line nil)
  (newline-and-indent))

(global-set-key [(shift return)] 'smart-open-line)
(global-set-key "\C-o" 'smart-open-line)


(defun smart-line-beginning ()
  "Move point to the beginning of text
  on the current line; if that is already
  the current position of point, then move
  it to the beginning of the line."
  (interactive)
  (let ((pt (point)))
    (beginning-of-line-text)
    (when (eq pt (point))
      (beginning-of-line))))

(global-set-key "\C-a" 'smart-line-beginning)
;; ==

;; = Increment/decrement integer

(require 'thingatpt)

(defun thing-at-point-goto-end-of-integer ()
  "Go to end of integer at point."
  (let ((inhibit-changing-match-data t))
    ;; Skip over optional sign
    (when (looking-at "[+-]")
      (forward-char 1))
    ;; Skip over digits
    (skip-chars-forward "[[:digit:]]")
    ;; Check for at least one digit
    (unless (looking-back "[[:digit:]]")
      (error "No integer here"))))
(put 'integer 'beginning-op 'thing-at-point-goto-end-of-integer)

(defun thing-at-point-goto-beginning-of-integer ()
  "Go to end of integer at point."
  (let ((inhibit-changing-match-data t))
    ;; Skip backward over digits
    (skip-chars-backward "[[:digit:]]")
    ;; Check for digits and optional sign
    (unless (looking-at "[+-]?[[:digit:]]")
      (error "No integer here"))
    ;; Skip backward over optional sign
    (when (looking-back "[+-]")
      (backward-char 1))))
(put 'integer 'beginning-op 'thing-at-point-goto-beginning-of-integer)

(defun thing-at-point-bounds-of-integer-at-point ()
  "Get boundaries of integer at point."
  (save-excursion
    (let (beg end)
      (thing-at-point-goto-beginning-of-integer)
      (setq beg (point))
      (thing-at-point-goto-end-of-integer)
      (setq end (point))
      (cons beg end))))
(put 'integer 'bounds-of-thing-at-point 'thing-at-point-bounds-of-integer-at-point)

(defun thing-at-point-integer-at-point ()
  "Get integer at point."
  (let ((bounds (bounds-of-thing-at-point 'integer)))
    (string-to-number (buffer-substring (car bounds) (cdr bounds)))))
(put 'integer 'thing-at-point 'thing-at-point-integer-at-point)

(defun increment-integer-at-point (&optional inc)
  "Increment integer at point by one.
     
     With numeric prefix arg INC, increment the integer by INC amount."
  (interactive "p")
  (let ((inc (or inc 1))
        (n (thing-at-point 'integer))
        (bounds (bounds-of-thing-at-point 'integer)))
    (delete-region (car bounds) (cdr bounds))
    (insert (int-to-string (+ n inc)))))

(defun decrement-integer-at-point (&optional dec)
  "Decrement integer at point by one.
     
     With numeric prefix arg DEC, decrement the integer by DEC amount."
  (interactive "p")
  (increment-integer-at-point (- (or dec 1))))

(global-set-key (kbd "C-c +") 'increment-integer-at-point)
(global-set-key (kbd "C-c -") 'decrement-integer-at-point)
;; ===

(defun eval-and-replace ()
  "Replace the preceding sexp with its value."
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))
(global-set-key (kbd "C-c e") 'eval-and-replace)

(global-set-key(kbd"RET")'newline-and-indent)

(defun kill-region-or-backward-word ()
  (interactive)
  (if (region-active-p)
      (kill-region (point) (mark))
    (backward-kill-word 1)))
(define-key global-map "\C-w" 'kill-region-or-backward-word)
   
* Projectile

  [[https://github.com/bbatsov/projectile][bbatsov/projectile]]

  #+begin_src emacs-lisp
    (projectile-global-mode)
    (diminish 'projectile-mode)
  #+end_src
  
* Org mode

** Setup and preferences

   #+begin_src emacs-lisp
    (require 'org-install)
    (require 'org-protocol)

    (setq org-entities-user '(("space" "\\ " nil " " " " " " " ")))
    (add-hook 'org-mode-hook 'turn-on-visual-line-mode)

    ;; Flie types Emacs should open in org-mode
    (add-to-list 'auto-mode-alist '("\\.org$" . org-mode))
    (add-to-list 'auto-mode-alist '("\\.txt$" . org-mode))
    (add-to-list 'auto-mode-alist '("\\.bml$" . org-mode))

    ;; (setq org-completion-use-ido t)
    (setq org-mobile-force-id-on-agenda-items nil)
    (add-hook 'org-shiftup-final-hook 'windmove-up)
    (add-hook 'org-shiftleft-final-hook 'windmove-left)
    (add-hook 'org-shiftdown-final-hook 'windmove-down)
    (add-hook 'org-shiftright-final-hook 'windmove-right)

    ;; So we can use "*bold*" and '*bold*'
    (setq org-emphasis-regexp-components
          '(" \t({" "- \t.,:!?;)}\\" " \t\r\n," "." 1))
    (setq org-startup-with-inline-images t)

    (define-key global-map "\C-cl" 'org-store-link)
    (define-key global-map "\C-cc" 'org-capture)
    (define-key global-map "\C-ca" 'org-agenda)
    (define-key global-map "\C-cb" 'org-iswitchb)
    (define-key global-map "\C-cy" 'ess/org-yank-link)
   #+end_src

** Files

   #+begin_src emacs-lisp
    (setq org-directory "~/org/")
    (setq org-default-notes-file (concat org-directory "/notes.txt"))
    (setq org-mobile-directory "~/Dropbox/Apps/MobileOrg")
    (setq org-mobile-inbox-for-pull "~/org/mobileorg.org")
    (setq org-mobile-files '("~/org/gtd.txt"
                             "~/org/someday.txt"
                             "~/org/notes.txt"
                             "~/org/calendar.txt"
                             "~/org/journal.txt"))

    (setq org-agenda-files '("~/org/gtd.txt"
                             "~/org/notes.txt"
                             "~/org/calendar.txt"
                             "~/org/journal.txt"))
   #+end_src

** Todos

   #+begin_src emacs-lisp
     (setq org-use-fast-todo-selection t)
     (setq org-todo-keywords
           '((sequence "TODO(t)" "NEXT(n)" "VERIFY(v)" "STARTED(s)" "|" "WAITING(w!)" "DONE(d!)" "DELEGATED(g!)" "CANCELLED(c!)")))

     (setq org-agenda-custom-commands
           '(("h" "Todo lists"
              ((agenda)
               (tags-todo "@home")
               (tags-todo "@work")
               (tags-todo "@town")
               (tags-todo "@computer")
               (tags-todo "@windows")
               (tags-todo "@linux")
               (tags-todo "@borås")
               (tags-todo "@phone")
               (tags-todo "@ipad")
               (tags-todo "@göteborg")))))
   #+end_src

** Apps

   #+begin_src emacs-lisp
    (delete '("\\.pdf\\'" . default) org-file-apps)
    (add-to-list 'org-file-apps '("\\.pdf$" . "zathura \"%s\""))
    (add-to-list 'org-file-apps '("\\.pdf::\\([0-9]+\\)\\'" . "zathura \"%s\" -P %1"))
   #+end_src

** Capture and refile

   #+begin_src emacs-lisp
     (setq org-capture-templates
           '(
             ("t" "Todo" entry (file+headline "~/org/gtd.txt" "Inbox")
              "* TODO %? \n  %i\n  %a \n Added: %u\n\n")
             ("n" "Note" entry (file "~/org/notes.txt")
              "* %? \n  Added: %u\n  %a \n\n  %i")
             ("s" "Someday" entry (file+headline "~/org/someday.txt" "Someday")
              "* %? \n  Added: %u\n  %a \n\n  %i")
             ("m" "Maybe" entry (file+headline "~/org/someday.txt" "Maybe")
              "* %? \n  Added: %u\n  %a \n\n  %i")
             ("b" "Bookmark" entry (file "~/org/bookmarks.txt")
              "* [[%:link][%^{Title|%:description}]]   %^g \n  %?\n  Added: %u\n\n  %i"
              :empty-lines 1)
             ("j" "Journal" entry (file+datetree "~/org/journal.txt")
              "** %? \n\n   %i")
             ("c" "Calendar" entry (file+datetree "~/org/calendar.txt")
              "** %? \n\n   %i")
             ))

     (setq org-refile-targets
           '(
             (nil . (:maxlevel . 5))
             (org-agenda-files . (:maxlevel . 5))
             ("~/org/someday.txt" . (:maxlevel . 1))
             ))

     ; Use full outline paths for refile targets - we file directly with IDO
     ;; (setq org-refile-use-outline-path t)

     ; Targets complete directly with IDO
     ;; (setq org-outline-path-complete-in-steps nil)

     ; Allow refile to create parent tasks with confirmation
     (setq org-refile-allow-creating-parent-nodes (quote confirm))

     ; Use IDO for both buffer and file completion and ido-everywhere to t
     ;; (setq org-completion-use-ido t)

     ;;;; Refile settings
     ; Exclude DONE state tasks from refile targets
     (defun bh/verify-refile-target ()
       "Exclude todo keywords with a done state from refile targets"
       (not (member (nth 2 (org-heading-components)) org-done-keywords)))

     (setq org-refile-target-verify-function 'bh/verify-refile-target)
   #+end_src

   Command that yanks as an org-mode link

   #+BEGIN_SRC emacs-lisp
     (defun ess/org-yank-link ()
       (interactive)
       (insert "[[")
       (yank)
       (insert "][]]")
       (backward-char 2))
   #+END_SRC

** Deft

  #+begin_src emacs-lisp
    (setq deft-extension "txt")
    (setq deft-text-mode 'org-mode)
    (global-set-key [f9] 'deft)
    (add-hook 'org-capture-mode-hook 'evil-emacs-state)
    (setq deft-directory org-directory)
    (setq deft-use-filename-as-title t)
  #+end_src

** Babel

   #+begin_src emacs-lisp
     ; Make babel results blocks lowercase
     (setq org-babel-results-keyword "results")

     (org-babel-do-load-languages
      (quote org-babel-load-languages)
      (quote ((emacs-lisp . t)
              (dot . t)
              (ditaa . t)
              (R . t)
              (python . t)
              (ruby . t)
              (gnuplot . t)
              (clojure . t)
              (sh . t)
              (ledger . t)
              (org . t)
              (plantuml . t)
              (latex . t))))

     ;; ; Do not prompt to confirm evaluation
     ;; ; This may be dangerous - make sure you understand the consequences
     ;; ; of setting this -- see the docstring for details
     ;; (setq org-confirm-babel-evaluate nil)
   #+end_src
** Open files

   #+begin_src emacs-lisp
     (find-file "~/org/gtd.txt")
     (find-file "~/org/notes.txt")
   #+end_src
* LaTeX

  #+begin_src emacs-lisp
    (setq TeX-auto-save t) 
    (setq TeX-parse-self t) 
    (setq TeX-save-query nil)
    (setq TeX-PDF-mode t)
    
    (setq-default TeX-master nil)
    (setq-default TeX-master "master")
    
    (if system-type 'gnu/linux
      (setq TeX-view-program-list '(("zathura" "zathura %o"))
            TeX-view-program-selection '((output-pdf "zathura"))))
        
    (setq TeX-view-program-selection '((output-pdf "zathura")))
    
    (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
    (add-hook 'LaTeX-mode-hook 'turn-on-visual-line-mode)
    (add-hook 'LaTeX-mode-hook 'orgtbl-mode)
    ;; (add-hook 'LaTeX-mode-hook 'flyspell-mode)
    ;; (add-hook 'LaTeX-mode-hook 'flyspell-buffer)
    (setq reftex-plug-into-AUCTeX t)
  #+end_src

* Programming

  Make a shell script executable automatically on save.

  #+begin_src emacs-lisp
    (add-hook 'after-save-hook
              'executable-make-buffer-file-executable-if-script-p)
    
    (add-to-list 'auto-mode-alist '("\\.zsh\\'" . shell-script-mode))
  #+end_src

  Default hook for programming.

  #+begin_src emacs-lisp
    (defun prelude-font-lock-comment-annotations ()
      "Highlight a bunch of well known comment annotations.

    This functions should be added to the hooks of major modes for programming."
      (font-lock-add-keywords
       nil '(("\\<\\(\\(FIX\\(ME\\)?\\|TODO\\|OPTIMIZE\\|HACK\\|REFACTOR\\):\\)"
              1 font-lock-warning-face t))))

    (defun prelude-prog-mode-defaults ()
      "Default coding hook, useful with any programming language."
      (smartparens-mode +1)
      (rainbow-delimiters-mode +1)
      (prelude-font-lock-comment-annotations))

    (setq prelude-prog-mode-hook 'prelude-prog-mode-defaults)

    (require 'which-func)
    (which-function-mode 1)

    (add-hook 'prog-mode-hook (lambda ()
                                (run-hooks 'prelude-prog-mode-hook)))

    (require 'yafolding)
    (define-key yafolding-mode-map (kbd "<C-S-return>") nil)
    (define-key yafolding-mode-map (kbd "<C-return>") nil)
    (define-key yafolding-mode-map (kbd "C-c <C-S-return>") 'yafolding-toggle-all)
    (define-key yafolding-mode-map (kbd "C-c <C-return>") 'yafolding-toggle-element)

    (add-hook 'prog-mode-hook
              (lambda () (yafolding-mode)))


  #+end_src

** AutoHotKey

   #+begin_src emacs-lisp
     (autoload 'xahk-mode "xahk-mode" "Load xahk-mode for editing AutoHotkey scripts." t)
     (add-to-list 'auto-mode-alist '("\\.ahk\\'" . xahk-mode))
     (defalias 'ahk-mode 'xahk-mode) ; make it easier to remember.
   #+end_src

** Web Development

   #+begin_src emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.php$" . web-mode))
     (add-to-list 'auto-mode-alist '("\\.htm$" . web-mode))
     (add-to-list 'auto-mode-alist '("\\.html$" . web-mode))
     (add-hook 'web-mode-hook '(lambda ()
       (local-set-key (kbd "RET") 'newline-and-indent)
       (emmet-mode)))
     (custom-set-variables '(coffee-tab-width 2))
   #+end_src

*** CSS

   #+begin_src emacs-lisp
     (add-hook 'css-mode-hook (lambda () (rainbow-mode +1)))
     (eval-after-load 'css-mode (setq css-indent-offset 2))
   #+end_src

** Python

#+BEGIN_SRC emacs-lisp
  (if (string-equal system-type "gnu/linux")
      (progn (add-hook 'python-mode-hook 'jedi:setup)
             (setq jedi:complete-on-dot t)))
#+END_SRC
   
* Dired and bookmarks

  #+begin_src emacs-lisp
     (setq bmkp-prompt-for-tags-flag 1)
     (bookmark-bmenu-list)
     (switch-to-buffer "*Bookmark List*")
     
     ;; dired - reuse current buffer by pressing 'a'
     (put 'dired-find-alternate-file 'disabled nil)
     
     ;; always delete and copy recursively
     (setq dired-recursive-deletes 'always)
     (setq dired-recursive-copies 'always)
     
     (require 'dired+)
     
     ;; dired, better searching (filenames)
     (setq dired-isearch-filenames t)
     
     (put 'dired-find-alternate-file 'disabled nil)
     
     (require 'dired-x)
     (setq-default dired-omit-files-p t) ;; this is buffer-local variable
     (setq dired-omit-files
           (concat dired-omit-files "\\|^\\..+$")) ;; dot-files are omitted
     
     (setq dired-dwim-target t)
     
     (require 'dired-details)
     (setq-default dired-details-hidden-string nil)
     (dired-details-install)
     
     ;; Auto refresh buffers
     (global-auto-revert-mode 1)
     
     ;; Also auto refresh dired, but be quiet about it
     (setq global-auto-revert-non-file-buffers t)
     (setq auto-revert-verbose nil)
          
     (defun open-in-external-app ()
       "Open the current file or dired marked files in external app."
       (interactive)
       (let ( doIt
              (myFileList
               (cond
                ((string-equal major-mode "dired-mode") (dired-get-marked-files))
                (t (list (buffer-file-name))) ) ) )
         
         (setq doIt (if (<= (length myFileList) 5)
                        t
                      (y-or-n-p "Open more than 5 files?") ) )
         
         (when doIt
           (cond
            ((string-equal system-type "windows-nt")
             (mapc (lambda (fPath) (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" fPath t t)) ) myFileList)
             )
            ((string-equal system-type "darwin")
             (mapc (lambda (fPath) (shell-command (format "open \"%s\"" fPath)) )  myFileList) )
            ((string-equal system-type "gnu/linux")
             (mapc (lambda (fPath) (let ((process-connection-type nil)) (start-process "" nil "xdg-open" fPath)) ) myFileList) ) ) ) ) )

    (if system-type 'gnu/linux
      (progn
        (require 'openwith)
        (setq openwith-associations '(("\\.pdf\\'" "zathura" (file))))
        (setq openwith-associations '(("\\.doc\\'" "libreoffice" (file))))
        (setq openwith-associations '(("\\.docx\\'" "libreoffice" (file))))     
        (setq openwith-associations '(("\\.odt\\'" "libreoffice" (file))))     
        (openwith-mode t)))

     
     (global-set-key (kbd "<C-return>") 'open-in-external-app)

    (eval-after-load "dired-aux"
       '(add-to-list 'dired-compress-file-suffixes 
                     '("\\.zip\\'" ".zip" "unzip")))
  #+end_src

* Buffer manipulation

  Find file as root, bound to C-x F

  #+begin_src emacs-lisp
    (defun djcb-find-file-as-root ()
      "Like `ido-find-file, but automatically edit the file with
        root-privileges (using tramp/sudo), if the file is not writable by
        user."
      (interactive)
      (let ((file (ido-read-file-name "Edit as root: ")))
        (unless (file-writable-p file)
          (setq file (concat "/sudo:root@localhost:" file)))
        (find-file file)))
    ;; or some other keybinding...
    (global-set-key (kbd "C-x F") 'djcb-find-file-as-root)
  #+end_src

  Move between frames with shift + arrow keys

  #+begin_src emacs-lisp
    (when (fboundp 'windmove-default-keybindings)
      (windmove-default-keybindings))
    (setq windmove-wrap-around t)
  #+end_src

  Opens the current buffer in an external program, bound to C-c o

  #+begin_src emacs-lisp
    (defun open-with ()
      "Simple function that allows us to open the underlying
        file of a buffer in an external program."
      (interactive)
      (when buffer-file-name
        (shell-command (concat
                        (if (eq system-type 'darwin)
                            "open"
                          (read-shell-command "Open current file with: "))
                        " "
                        buffer-file-name))))
    
    (global-set-key (kbd "C-c o") 'open-with)
  #+end_src

  Renames the current buffer, and its file. Bound to C-c r

  #+begin_src emacs-lisp
    (defun rename-file-and-buffer ()
      "Rename the current buffer and file it is visiting."
      (interactive)
      (let ((filename (buffer-file-name)))
        (if (not (and filename (file-exists-p filename)))
            (message "Buffer is not visiting a file!")
          (let ((new-name (read-file-name "New name: " filename)))
            (cond
             ((vc-backend filename) (vc-rename-file filename new-name))
             (t
              (rename-file filename new-name t)
              (rename-buffer new-name)
              (set-visited-file-name new-name)
              (set-buffer-modified-p nil)))))))
    
    (global-set-key (kbd "C-c r")  'rename-file-and-buffer)
  #+end_src

  Mouse navigation of buffers hack

  #+begin_src emacs-lisp
    (global-set-key (kbd "<C-S-iso-lefttab>") 'previous-buffer)
    (global-set-key (kbd "<C-tab>") 'next-buffer)
  #+end_src

  Switching to other buffers via shortcuts, like Conkeror. M-n and M-p
  is for user buffers and C-S-PageUp and C-S-PageDown is for Emacs buffers.

  #+begin_src emacs-lisp
    (defun next-user-buffer ()
      "Switch to the next user buffer.
        User buffers are those whose name does not start with *."
      (interactive)
      (next-buffer)
      (let ((i 0))
        (while (and (string-match "^*" (buffer-name)) (< i 50))
          (setq i (1+ i)) (next-buffer) )))
    
    (defun previous-user-buffer ()
      "Switch to the previous user buffer.
        User buffers are those whose name does not start with *."
      (interactive)
      (previous-buffer)
      (let ((i 0))
        (while (and (string-match "^*" (buffer-name)) (< i 50))
          (setq i (1+ i)) (previous-buffer) )))
    
    (defun next-emacs-buffer ()
      "Switch to the next emacs buffer.
        Emacs buffers are those whose name starts with *."
      (interactive)
      (next-buffer)
      (let ((i 0))
        (while (and (not (string-match "^*" (buffer-name))) (< i 50))
          (setq i (1+ i)) (next-buffer) )))
    
    (defun previous-emacs-buffer ()
      "Switch to the previous emacs buffer.
        Emacs buffers are those whose name starts with *."
      (interactive)
      (previous-buffer)
      (let ((i 0))
        (while (and (not (string-match "^*" (buffer-name))) (< i 50))
          (setq i (1+ i)) (previous-buffer) )))
    
  #+end_src

* The WWW

  #+begin_src emacs-lisp
    (if (string-equal system-type "gnu/linux") 
        (setq browse-url-browser-function 'browse-url-generic
              browse-url-generic-program "/home/ess/bin/conkeror.sh"))
  #+end_src

* Evil

  Set it up!

  #+begin_src emacs-lisp
    (require 'evil)
    (require 'evil-leader)
    (global-evil-leader-mode)
    (evil-mode t)
  #+end_src
  
  I want to be in Emacs mode when in insert mode.

  #+begin_src emacs-lisp
    (setcdr evil-insert-state-map nil)
    (define-key evil-insert-state-map
    (read-kbd-macro evil-toggle-key) 'evil-emacs-state)
    
    (define-key evil-insert-state-map [escape] 'evil-normal-state)
  #+end_src

  We want to enter Normal mode when pressing jj rapidly.

  #+begin_src emacs-lisp
    (require 'key-chord)
    (key-chord-define evil-insert-state-map "jj" 'evil-normal-state)
    (key-chord-define evil-insert-state-map "qe" (lambda () (interactive) (insert "é")))
    (key-chord-mode 1)
  #+end_src

  We should go down by visual lines, not logical lines

  #+begin_src emacs-lisp
    (define-key evil-normal-state-map (kbd "j") 'evil-next-visual-line)
    (define-key evil-normal-state-map (kbd "k") 'evil-previous-visual-line)
  #+end_src

  Ace jump to word when pressing space

  #+begin_src emacs-lisp
    (define-key evil-normal-state-map (kbd "SPC") 'ace-jump-word-mode)
  #+end_src

  Start in insert mode when capturing

  #+begin_src emacs-lisp
    (add-hook 'org-capture-mode-hook 'evil-insert-state)
  #+end_src

  [[https://github.com/wcsmith/evil-args][Evil args]] Man kan ändra argument i stil med cia, ta bort med daa
  eller gå frammåt/bakåt med HJKL.

  #+begin_src emacs-lisp
    (require 'evil-args)

    ;; bind evil-args text objects
    (define-key evil-inner-text-objects-map "a" 'evil-inner-arg)
    (define-key evil-outer-text-objects-map "a" 'evil-outer-arg)

    ;; bind evil-forward/backward-args
    (define-key evil-normal-state-map "L" 'evil-forward-arg)
    (define-key evil-normal-state-map "H" 'evil-backward-arg)
    (define-key evil-motion-state-map "L" 'evil-forward-arg)
    (define-key evil-motion-state-map "H" 'evil-backward-arg)

    ;; bind evil-jump-out-args
    (define-key evil-normal-state-map "K" 'evil-jump-out-args)
  #+end_src

  [[https://github.com/timcharper/evil-surround][Evil surround]]. ys<textobject><trigger> omringar med tecken, räcker
  med s in visual-state. cs<old><new> och ds<trigger> funkar

  #+begin_src emacs-lisp
    (require 'evil-surround)
    (global-evil-surround-mode 1)
  #+end_src

  Nerd commenter

  #+begin_src emacs-lisp
    (setq evilnc-hotkey-comment-operator "öö")
    (require 'evil-nerd-commenter)
    (global-set-key (kbd "M-;") 'evilnc-comment-or-uncomment-lines)
  #+end_src
  
  Leader key (ö) stuff

  - f :: Find file
  - b :: Switch buffer
  - k :: Kill buffer

  #+begin_src emacs-lisp
    (evil-leader/set-leader "ö")
    (evil-leader/set-key
      "f" 'find-file
      "b" 'switch-to-buffer
      "k" 'kill-this-buffer
      "ci" 'evilnc-comment-or-uncomment-lines
      "cl" 'evilnc-quick-comment-or-uncomment-to-the-line
      "ll" 'evilnc-quick-comment-or-uncomment-to-the-line
      "cc" 'evilnc-copy-and-comment-lines
      "cp" 'evilnc-comment-or-uncomment-paragraphs
      "cr" 'comment-or-uncomment-region
      "cv" 'evilnc-toggle-invert-comment-line-by-line)
  #+end_src

* Neotree

  #+begin_src emacs-lisp
    (require 'neotree)
    (add-hook 'neotree-mode-hook 'evil-emacs-state)
    (define-key neotree-mode-map (kbd "j") 'next-line)
    (define-key neotree-mode-map (kbd "k") 'previous-line)
    (global-set-key [f8] 'neotree-toggle)
  #+end_src
  
* Work related

  #+begin_src emacs-lisp
    (defun ess/org-field-to-kill-ring ()
      "Inserts the current org-mode table field into the kill ring"
      (interactive)
      (let ((start (point)))
        (org-table-end-of-field 1)
        (copy-region-as-kill start (point))))

    (defun ess/timeedit-csv-to-orgmode ()
      "Converts a CSV file from TimeEdit, converted into an org-mode table, into org-mode headings"
      (interactive)
      (org-insert-heading)
      (other-window 1)
      (org-table-goto-column 6) ;; The course name
      (ess/org-field-to-kill-ring)
      (other-window 1)
      (yank)
      (insert " - ")
      (other-window 1)
      (org-table-goto-column 10) ;; The type of moment
      (ess/org-field-to-kill-ring)
      (other-window 1)
      (yank)
      (org-return-indent)
      (insert "<")
      (other-window 1)
      (org-table-goto-column 1) ;; Date
      (ess/org-field-to-kill-ring)
      (other-window 1)
      (yank)
      (insert " ")
      (other-window 1)
      (org-table-next-field) ;; Start time
      (ess/org-field-to-kill-ring)
      (other-window 1)
      (yank)
      (insert "-")
      (other-window 1)
      (org-table-goto-column 4) ;; End time
      (ess/org-field-to-kill-ring)
      (other-window 1)
      (yank)
      (insert ">")
      (org-return-indent)
      (insert "Sal: ")
      (other-window 1)
      (org-table-goto-column 5) ;; Location
      (ess/org-field-to-kill-ring)
      (next-line)
      (other-window 1)
      (yank)
      (newline))
  #+end_src
* Global shortcuts

  Here's the keys that are defined in all modes.

** Multiple cursors

   #+begin_src emacs-lisp
     (mapc
      (lambda (keyscommand)
        (global-set-key 
         (kbd (concat "C-c m " (car keyscommand)))
         (cdr keyscommand)))
      '(
        ("n" . mc/mark-next-like-this)
        ("w" . mc/mark-next-word-like-this)
        ("s" . mc/mark-next-symbol-like-this)
        ("p" . mc/mark-previous-like-this)
        ("W" . mc/mark-previous-word-like-this)
        ("S" . mc/mark-previous-symbol-like-this)
        ("m" . mc/mark-more-like-this-extended)
        ("l" . mc/edit-lines)
        ("a" . mc/edit-beginnings-of-lines)
        ("e" . mc/edit-ends-of-lines)
        ("C-s" . mc/mark-all-in-region)
        ("*" . mc/mark-all-like-this)
        ("<" . mc/mark-sgml-tag-pair)
        (">" . mc/mark-sgml-tag-pair)
        ))

     (global-unset-key (kbd "M-<down-mouse-1>"))
     (global-set-key (kbd "M-<mouse-1>") 'mc/add-cursor-on-click)
   #+end_src

** § leader key

   #+begin_src emacs-lisp
     ;; Use § as a leader key 
     (global-unset-key (kbd "§"))

     (mapc
      (lambda (keyscommand)
        (global-set-key 
         (kbd (concat "§ " (car keyscommand)))
         (cdr keyscommand)))
      '(
        ("§" . (lambda () (interactive) (insert "§")))
        ("0" . delete-window)
        ("1" . delete-other-windows)
        ("2" . split-window-below)
        ("3" . split-window-right)
        ("w" . ace-window)
        ("r" . recentf-open-files)
        ("u" . undo-tree-visualize)
        ("m" . magit-status)
        ("n" . neotree-toggle)
        ("d" . deft)
        ("s" . sunrise)
        ("<SPC>" . ace-jump-mode)
        ("o" . ace-window)
        ("f" . helm-projectile-find-file)
        ("i" . (lambda () (interactive) (find-file "~/.emacs.d/evilinit.org")))
        ))
   #+end_src

** Anti shift key

   #+begin_src emacs-lisp
     (mapc
      (lambda (keyscommand)
        (key-chord-define evil-insert-state-map
         (car keyscommand) (cdr keyscommand)))
      '(
        ("1j" . "!")
        ("2j" . "\"")
        ("3j" . "#")
        ("4j" . "$")
        ("5j" . "%")
        ("6f" . "&")
        ("7f" . "/")
        ("8f" . "(")
        ("9f" . ")")
        ("0f" . "=")
        ("+f" . "?")
        ("-f" . "_")
        (".f" . ":")
        (",f" . ";")
        ))
   #+end_src

** Other

   #+begin_src emacs-lisp
      (global-set-key (kbd "M-j")
                      (lambda ()
                        (interactive)
                        (join-line -1)))

      (global-set-key (kbd "C-c e") 'eval-and-replace)

      (require 'expand-region)
      (global-set-key (kbd "C-0") 'er/expand-region)
      (global-set-key (kbd "C-9") 'mc/mark-next-like-this)
      (global-set-key (kbd "C-8") 'mc/mark-all-like-this)

      ;; (global-set-key (kbd "<return>") 'newline-and-indent)
      ;; (global-set-key (kbd "M-x") 'smex)
      ;; (global-set-key (kbd "M-X") 'smex-major-mode-commands)
      (global-set-key "\M-n" 'next-user-buffer)
      (global-set-key "\M-p" 'previous-user-buffer)
      (global-set-key (kbd "<C-prior>") 'previous-emacs-buffer) ; Ctrl+Shift+PageUp
      (global-set-key (kbd "<C-next>") 'next-emacs-buffer) ; Ctrl+Shift+PageDown
      (global-set-key (kbd "C-c u") 'browse-url)
      (global-set-key (kbd "C-c s") 'yas-insert-snippet)
      (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))

     ;; M-a and M-e should take us to the next blank line
     (global-set-key "\M-a" 'endless/backward-paragraph)
     (global-set-key "\M-e" 'endless/forward-paragraph)

     (defun endless/forward-paragraph (&optional n)
       "Advance just past next blank line."
       (interactive "p")
       (let ((m (use-region-p))
             (para-commands
              '(endless/forward-paragraph endless/backward-paragraph)))
         ;; Only push mark if it's not active and we're not repeating.
         (or m
             (not (member this-command para-commands))
             (member last-command para-commands)
             (push-mark))
         ;; The actual movement.
         (dotimes (_ (abs n))
           (if (> n 0)
               (skip-chars-forward "\n[:blank:]")
             (skip-chars-backward "\n[:blank:]"))
           (if (search-forward-regexp
                "\n[[:blank:]]*\n[[:blank:]]*" nil t (cl-signum n))
               (goto-char (match-end 0))
             (goto-char (if (> n 0) (point-max) (point-min)))))
         ;; If mark wasn't active, I like to indent the line too.
         (unless m
           (indent-according-to-mode)
           ;; This looks redundant, but it's surprisingly necessary.
           (back-to-indentation))))

     (defun endless/backward-paragraph (&optional n)
       "Go back up to previous blank line."
       (interactive "p")
       (endless/forward-paragraph (- n)))
   #+end_src
   

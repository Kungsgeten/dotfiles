* Install packages

  #+begin_src emacs-lisp
    (require 'package)
    (package-initialize)

    (add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/"))

    (defvar my-packages '(ace-jump-mode
                          anzu
                          auctex
                          bookmark+
                          deft
                          dired+ dired-details+
                          diminish
                          expand-region
                          flycheck
                          htmlize
                          key-chord
                          lua-mode
                          markdown-mode
                          magit
                          multiple-cursors
                          ox-reveal
                          smex
                          smartparens
                          slime rainbow-delimiters
                          undo-tree
                          web-mode
                          yascroll
                          yasnippet
                          zenburn-theme
                          zencoding-mode rainbow-mode)
      "List of packages to install at launch")

    (if system-type 'gnu/linux
      (setq my-packages (append my-packages '(ac-nrepl nrepl clojure-mode clojure-cheatsheet))))

    (defun my-missing-packages ()
      (let (missing-packages)
        (dolist (package my-packages (reverse missing-packages))
          (or (package-installed-p package)
    (push package missing-packages)))))

    (defun ensure-my-packages ()
      (let ((missing (my-missing-packages)))
        (when missing
          ;; Check for new packages (package versions)
          (package-refresh-contents)
          ;; Install the missing packages
          (mapc (lambda (package)
    (when (not (package-installed-p package))
    (package-install package)))
    missing)
          ;; Close the compilation log.
          (let ((compile-window (get-buffer-window "*Compile-Log*")))
    (if compile-window
    (delete-window compile-window))))))

    (ensure-my-packages)
  #+end_src

* Emacs init

  #+begin_src emacs-lisp
    (setq frame-title-format '("emacs"))
    (if system-type 'gnu/linux
      (set-frame-font "Terminus-10"))
    
    (let ((default-directory "~/.emacs.d/plugins/"))
      (normal-top-level-add-to-load-path '("" "ledger")))
    
    (load "ledger-mode")
    
    (package-initialize)
    (load-theme 'zenburn t)
    
    (setq make-backup-files t)
    (setq version-control t
          backup-by-copying t
          delete-old-versions t
          kept-old-versions 6
          kept-new-versions 9)
    (setq backup-directory-alist (quote ((".*" . "~/.emacs.d/backups/"))))
  #+end_src

* Personal info

  #+begin_src emacs-lisp
    (setq user-mail-address "sjostrand.erik@gmail.com")
    (setq user-full-name "Erik Sjöstrand")
  #+end_src

* General configuration

  First we tidy up Emacs and get rid of stuff we do not want in the
  GUI. We also add GUI things we actually want, like Anzu and yascroll.

  #+begin_src emacs-lisp
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (column-number-mode t)
  (blink-cursor-mode 0)
  (show-smartparens-global-mode +1)
  (setq ring-bell-function 'ignore)
  (setq inhibit-startup-screen 1)
  (fset 'yes-or-no-p 'y-or-n-p)
  (global-hl-line-mode +1)
  (scroll-bar-mode -1)
  (require 'yascroll)
  (global-yascroll-bar-mode 1)
  ;; make the fringe (gutter) smaller
  ;; the argument is a width in pixels (the default is 8)
  (if (fboundp 'fringe-mode)
      (fringe-mode 4))

  ;; diminish keeps the modeline tidy
  (require 'diminish)
  
  (require 'anzu)
  (global-anzu-mode +1)
  (diminish 'anzu-mode)

  ;; enable winner-mode to manage window configurations
  ;; (winner-mode +1)
  #+end_src

  The code below make Emacs more to my liking, regarding tabs,
  deletion of selections, scrolling and coding-systems.

  #+begin_src emacs-lisp
  (add-hook 'after-init-hook 'yas-global-mode)
  ;; (global-set-key (kbd "C-x C-b") 'ibuffer)
  
  (setq-default indent-tabs-mode nil)
  (pending-delete-mode 1)
      
  (setq
   scroll-margin 5
   scroll-conservatively 100000
   scroll-preserve-screen-position 1)
    
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  
  (global-set-key [remap goto-line] 'goto-line-with-feedback)

  ;; sensible undo
  (global-undo-tree-mode)
  (diminish 'undo-tree-mode)  
  #+end_src

  Some general functions:

  #+begin_src emacs-lisp
    (defun ess/new-leftframe ()
      "Creates a new frame with fontsize suitable for the left screen"
      (interactive)
      (set-frame-font "Terminus-18" nil (list (make-frame))))
  #+end_src

** History and save files

   #+begin_src emacs-lisp
  ;; saveplace remembers your location in a file when saving files
  (require 'saveplace)
  (setq save-place-file (expand-file-name "saveplace" user-emacs-directory))
  ;; activate it for all buffers
  (setq-default save-place t)
  
  ;; savehist keeps track of some history
  (require 'savehist)
  (setq savehist-additional-variables
        ;; search entries
        '(search ring regexp-search-ring)
        ;; save every minute
        savehist-autosave-interval 60
        ;; keep the home clean
        savehist-file (expand-file-name "savehist" user-emacs-directory))
  (savehist-mode +1)
  
  ;; save recent files
  (require 'recentf)
  (setq recentf-save-file (expand-file-name "recentf" user-emacs-directory)
        recentf-max-saved-items 500
        recentf-max-menu-items 15)
  (recentf-mode +1)
  
  (global-auto-revert-mode t)
   #+end_src

** Ido

#+begin_src emacs-lisp
  (require 'ido)
  (require 'ido-vertical-mode)
  (ido-mode 1)
  (ido-vertical-mode 1)
  (ido-everywhere t)
  (setq ido-enable-flex-matching t)
  (setq smex-save-file "~/.emacs.d/.smex-items")
#+end_src


* Text editing

  Enables stuff which is disabled by default.

  #+begin_src emacs-lisp
    (put 'narrow-to-region 'disabled nil)
    (put 'narrow-to-page 'disabled nil)
    (put 'narrow-to-defun 'disabled nil)
    (put 'upcase-region 'disabled nil)
    (put 'downcase-region 'disabled nil)
  #+end_src

  Eval and replace

  #+begin_src emacs-lisp
    (defun eval-and-replace ()
      "Replace the preceding sexp with its value."
      (interactive)
      (backward-kill-sexp)
      (condition-case nil
          (prin1 (eval (read (current-kill 0)))
                 (current-buffer))
        (error (message "Invalid expression")
               (insert (current-kill 0)))))
  #+end_src

  An idea of using the dash key to insert underscore or regular dash depending on the context.

  #+begin_src emacs-lisp
    
    (defun smart-dash ()
      "Inserts an underscore by default, but a dash if preceeded by number or underscore"
      (if (equal (string (char-before)) "_") 
          (progn (delete-backward-char 1) (insert "-"))
          (if (member (char-before) '(?0 ?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9))
              (insert "-")
            (insert "_"))))
  #+end_src
** Deprecated

(defun compact-uncompact-block ()
  "Remove or add line ending chars on current paragraph.
This command is similar to a toggle of `fill-paragraph'.
When there is a text selection, act on the region."
  (interactive)

  ;; This command symbol has a property "'stateIsCompact-p".
  (let (currentStateIsCompact (bigFillColumnVal 90002000) (deactivate-mark nil))
    ;; 90002000 is just random. you can use `most-positive-fixnum'

    (save-excursion
      ;; Determine whether the text is currently compact.
      (setq currentStateIsCompact
            (if (eq last-command this-command)
                (get this-command 'stateIsCompact-p)
              (if (> (- (line-end-position) (line-beginning-position)) fill-column) t nil) ) )

      (if (region-active-p)
          (if currentStateIsCompact
              (fill-region (region-beginning) (region-end))
            (let ((fill-column bigFillColumnVal))
              (fill-region (region-beginning) (region-end))) )
        (if currentStateIsCompact
            (fill-paragraph nil)
          (let ((fill-column bigFillColumnVal))
            (fill-paragraph nil)) ) )

      (put this-command 'stateIsCompact-p (if currentStateIsCompact nil t)) ) ) )

(global-set-key "\M-q" 'compact-uncompact-block)

;; = smart open and line, join line and line beginning

(defun smart-open-line ()
  "Insert an empty line after the current line.
   Position the cursor at its beginning, according to the current mode."
  (interactive)
  (move-end-of-line nil)
  (newline-and-indent))

(global-set-key [(shift return)] 'smart-open-line)
(global-set-key "\C-o" 'smart-open-line)


(defun smart-line-beginning ()
  "Move point to the beginning of text
  on the current line; if that is already
  the current position of point, then move
  it to the beginning of the line."
  (interactive)
  (let ((pt (point)))
    (beginning-of-line-text)
    (when (eq pt (point))
      (beginning-of-line))))

(global-set-key "\C-a" 'smart-line-beginning)
;; ==

;; = Increment/decrement integer

(require 'thingatpt)

(defun thing-at-point-goto-end-of-integer ()
  "Go to end of integer at point."
  (let ((inhibit-changing-match-data t))
    ;; Skip over optional sign
    (when (looking-at "[+-]")
      (forward-char 1))
    ;; Skip over digits
    (skip-chars-forward "[[:digit:]]")
    ;; Check for at least one digit
    (unless (looking-back "[[:digit:]]")
      (error "No integer here"))))
(put 'integer 'beginning-op 'thing-at-point-goto-end-of-integer)

(defun thing-at-point-goto-beginning-of-integer ()
  "Go to end of integer at point."
  (let ((inhibit-changing-match-data t))
    ;; Skip backward over digits
    (skip-chars-backward "[[:digit:]]")
    ;; Check for digits and optional sign
    (unless (looking-at "[+-]?[[:digit:]]")
      (error "No integer here"))
    ;; Skip backward over optional sign
    (when (looking-back "[+-]")
      (backward-char 1))))
(put 'integer 'beginning-op 'thing-at-point-goto-beginning-of-integer)

(defun thing-at-point-bounds-of-integer-at-point ()
  "Get boundaries of integer at point."
  (save-excursion
    (let (beg end)
      (thing-at-point-goto-beginning-of-integer)
      (setq beg (point))
      (thing-at-point-goto-end-of-integer)
      (setq end (point))
      (cons beg end))))
(put 'integer 'bounds-of-thing-at-point 'thing-at-point-bounds-of-integer-at-point)

(defun thing-at-point-integer-at-point ()
  "Get integer at point."
  (let ((bounds (bounds-of-thing-at-point 'integer)))
    (string-to-number (buffer-substring (car bounds) (cdr bounds)))))
(put 'integer 'thing-at-point 'thing-at-point-integer-at-point)

(defun increment-integer-at-point (&optional inc)
  "Increment integer at point by one.
     
     With numeric prefix arg INC, increment the integer by INC amount."
  (interactive "p")
  (let ((inc (or inc 1))
        (n (thing-at-point 'integer))
        (bounds (bounds-of-thing-at-point 'integer)))
    (delete-region (car bounds) (cdr bounds))
    (insert (int-to-string (+ n inc)))))

(defun decrement-integer-at-point (&optional dec)
  "Decrement integer at point by one.
     
     With numeric prefix arg DEC, decrement the integer by DEC amount."
  (interactive "p")
  (increment-integer-at-point (- (or dec 1))))

(global-set-key (kbd "C-c +") 'increment-integer-at-point)
(global-set-key (kbd "C-c -") 'decrement-integer-at-point)
;; ===

(defun eval-and-replace ()
  "Replace the preceding sexp with its value."
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))
(global-set-key (kbd "C-c e") 'eval-and-replace)

(global-set-key(kbd"RET")'newline-and-indent)

(defun kill-region-or-backward-word ()
  (interactive)
  (if (region-active-p)
      (kill-region (point) (mark))
    (backward-kill-word 1)))
(define-key global-map "\C-w" 'kill-region-or-backward-word)
   

* Org mode

  #+begin_src emacs-lisp
    (require 'org-install)

    (setq org-entities-user '(("space" "\\ " nil " " " " " " " ")))



    (add-to-list 'auto-mode-alist '("\\.org$" . org-mode))
    (add-to-list 'auto-mode-alist '("\\.txt$" . org-mode))
    (setq org-completion-use-ido t)
    (setq org-outline-path-complete-in-steps nil)
    (add-hook 'org-mode-hook 'turn-on-visual-line-mode)

    (setq org-directory "~/org/")
    (setq org-default-notes-file (concat org-directory "/notes.txt"))
    (setq org-use-fast-todo-selection t)
    (setq org-startup-with-inline-images t)
    (setq org-mobile-directory "~/Dropbox/Apps/MobileOrg")
    (setq org-mobile-inbox-for-pull "~/org/mobileorg.org")
    (setq org-mobile-files '("~/org/gtd.txt"
                             "~/org/someday.txt"
                             "~/org/notes.txt"
                             "~/org/calendar.txt"))
    (setq org-mobile-force-id-on-agenda-items nil)

    (add-hook 'org-shiftup-final-hook 'windmove-up)
    (add-hook 'org-shiftleft-final-hook 'windmove-left)
    (add-hook 'org-shiftdown-final-hook 'windmove-down)
    (add-hook 'org-shiftright-final-hook 'windmove-right)

    ;; So we can use "*bold*" and '*bold*'
    (setq org-emphasis-regexp-components
            '(" \t('\"{" "- \t.,:!?;'\")}\\" " \t\r\n," "." 1))

    (setq org-agenda-files '("~/org/gtd.txt"
                             "~/org/notes.txt"
                             "~/org/calendar.txt"))

    (find-file "~/org/gtd.txt")
    (find-file "~/org/notes.txt")
    ;; (org-mobile-push)

    ;; = Apps

    (delete '("\\.pdf\\'" . default) org-file-apps)
    (add-to-list 'org-file-apps '("\\.pdf$" . "zathura \"%s\""))
    (add-to-list 'org-file-apps '("\\.pdf::\\([0-9]+\\)\\'" . "zathura \"%s\" -P %1"))

    ;; = Shortcuts

    (define-key global-map "\C-cl" 'org-store-link)
    (define-key global-map "\C-cc" 'org-capture)
    (define-key global-map "\C-ca" 'org-agenda)
    (define-key global-map "\C-cb" 'org-iswitchb)

    ;; = Capture and refile

    (setq org-capture-templates
          '(
            ("t" "Todo" entry (file+headline "~/org/gtd.txt" "Inbox")
             "* TODO %? %^G \n  %i\n  %a \n Added: %u\n\n")
            ("n" "Note" entry (file "~/org/notes.txt")
             "* %? \n  Added: %u\n  %a \n\n  %i")
            ("b" "Bookmark" entry (file "~/org/bookmarks.org")
             "* [[%:link][%^{Title|%:description}]]   %^g \n  %?\n  Added: %u\n\n  %i"
             :empty-lines 1)
            ))

    (setq org-refile-targets
          '(
            (nil . (:level . 1))
            (org-agenda-files . (:level . 1))
          ))

    ;; = TODO tags

    (setq org-agenda-custom-commands
          '(("h" "Todo lists"
             ((agenda)
              (tags-todo "SKÖVDE")
              (tags-todo "HIS")
              (tags-todo "TOWN")
              (tags-todo "COMPUTER")
              (tags-todo "WINDOWS")
              (tags-todo "LINUX")
              (tags-todo "READING")
              (tags-todo "BORÅS")
              (tags-todo "PHONE")
              (tags-todo "GÖTEBORG")))))

    ;; Deft
    ;;;;;;;

    (setq deft-extension "txt")
    (setq deft-text-mode 'org-mode)
    (global-set-key [f9] 'deft)
    (setq deft-directory org-directory)
    (setq deft-use-filename-as-title t)
  #+end_src

* LaTeX

  #+begin_src emacs-lisp
    (setq TeX-auto-save t) 
    (setq TeX-parse-self t) 
    (setq TeX-save-query nil)
    (setq TeX-PDF-mode t)
    
    (setq-default TeX-master nil)
    (setq-default TeX-master "master")
    
    (if system-type 'gnu/linux
      (setq TeX-view-program-list '(("zathura" "zathura %o"))
            TeX-view-program-selection '((output-pdf "zathura"))))
        
    (setq TeX-view-program-selection '((output-pdf "zathura")))
    
    (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
    (add-hook 'LaTeX-mode-hook 'turn-on-visual-line-mode)
    (add-hook 'LaTeX-mode-hook 'orgtbl-mode)
    ;; (add-hook 'LaTeX-mode-hook 'flyspell-mode)
    ;; (add-hook 'LaTeX-mode-hook 'flyspell-buffer)
    (setq reftex-plug-into-AUCTeX t)
  #+end_src

* Programming

  Make a shell script executable automatically on save.

  #+begin_src emacs-lisp
    (add-hook 'after-save-hook
              'executable-make-buffer-file-executable-if-script-p)
    
    (add-to-list 'auto-mode-alist '("\\.zsh\\'" . shell-script-mode))
  #+end_src

  Default hook for programming.

  #+begin_src emacs-lisp
    (defun prelude-font-lock-comment-annotations ()
      "Highlight a bunch of well known comment annotations.
    
    This functions should be added to the hooks of major modes for programming."
      (font-lock-add-keywords
       nil '(("\\<\\(\\(FIX\\(ME\\)?\\|TODO\\|OPTIMIZE\\|HACK\\|REFACTOR\\):\\)"
              1 font-lock-warning-face t))))
    
    (defun prelude-prog-mode-defaults ()
      "Default coding hook, useful with any programming language."
      (smartparens-mode +1)
      (rainbow-delimiters-mode +1)
      (prelude-font-lock-comment-annotations))
    
    (setq prelude-prog-mode-hook 'prelude-prog-mode-defaults)
    
    (require 'which-func)
    (which-function-mode 1)
    
    (add-hook 'prog-mode-hook (lambda ()
                                (run-hooks 'prelude-prog-mode-hook)))
  #+end_src

** AutoHotKey

   #+begin_src emacs-lisp
     (autoload 'xahk-mode "xahk-mode" "Load xahk-mode for editing AutoHotkey scripts." t)
     (add-to-list 'auto-mode-alist '("\\.ahk\\'" . xahk-mode))
     (defalias 'ahk-mode 'xahk-mode) ; make it easier to remember.
   #+end_src

** Web Development

   #+begin_src emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.php$" . web-mode))
     (add-to-list 'auto-mode-alist '("\\.htm$" . web-mode))
     (add-to-list 'auto-mode-alist '("\\.html$" . web-mode))
   #+end_src

*** CSS

   #+begin_src emacs-lisp
     (add-hook 'css-mode-hook (lambda () (rainbow-mode +1)))
     (eval-after-load 'css-mode (setq css-indent-offset 2))
   #+end_src
eb 
* Dired and bookmarks

  #+begin_src emacs-lisp
    (setq bmkp-prompt-for-tags-flag 1)
    (bookmark-bmenu-list)
    (switch-to-buffer "*Bookmark List*")
    
    ;; dired - reuse current buffer by pressing 'a'
    (put 'dired-find-alternate-file 'disabled nil)
    
    ;; always delete and copy recursively
    (setq dired-recursive-deletes 'always)
    (setq dired-recursive-copies 'always)
    
    (require 'dired+)
    
    ;; dired, better searching (filenames)
    (setq dired-isearch-filenames t)
    
    (put 'dired-find-alternate-file 'disabled nil)
    
    (require 'dired-x)
    (setq-default dired-omit-files-p t) ;; this is buffer-local variable
    (setq dired-omit-files
          (concat dired-omit-files "\\|^\\..+$")) ;; dot-files are omitted
    
    (setq dired-dwim-target t)
    
    (require 'dired-details)
    (setq-default dired-details-hidden-string nil)
    (dired-details-install)
    
    ;; Auto refresh buffers
    (global-auto-revert-mode 1)
    
    ;; Also auto refresh dired, but be quiet about it
    (setq global-auto-revert-non-file-buffers t)
    (setq auto-revert-verbose nil)
    
    
    (defun open-in-external-app ()
      "Open the current file or dired marked files in external app."
      (interactive)
      (let ( doIt
             (myFileList
              (cond
               ((string-equal major-mode "dired-mode") (dired-get-marked-files))
               (t (list (buffer-file-name))) ) ) )
        
        (setq doIt (if (<= (length myFileList) 5)
                       t
                     (y-or-n-p "Open more than 5 files?") ) )
        
        (when doIt
          (cond
           ((string-equal system-type "windows-nt")
            (mapc (lambda (fPath) (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" fPath t t)) ) myFileList)
            )
           ((string-equal system-type "darwin")
            (mapc (lambda (fPath) (shell-command (format "open \"%s\"" fPath)) )  myFileList) )
           ((string-equal system-type "gnu/linux")
            (mapc (lambda (fPath) (let ((process-connection-type nil)) (start-process "" nil "xdg-open" fPath)) ) myFileList) ) ) ) ) )
    
    (global-set-key (kbd "<C-return>") 'open-in-external-app)
  #+end_src

* Buffer manipulation

  Find file as root, bound to C-x F

  #+begin_src emacs-lisp
    (defun djcb-find-file-as-root ()
      "Like `ido-find-file, but automatically edit the file with
        root-privileges (using tramp/sudo), if the file is not writable by
        user."
      (interactive)
      (let ((file (ido-read-file-name "Edit as root: ")))
        (unless (file-writable-p file)
          (setq file (concat "/sudo:root@localhost:" file)))
        (find-file file)))
    ;; or some other keybinding...
    (global-set-key (kbd "C-x F") 'djcb-find-file-as-root)
  #+end_src

  Move between frames with shift + arrow keys

  #+begin_src emacs-lisp
    (when (fboundp 'windmove-default-keybindings)
      (windmove-default-keybindings))
    (setq windmove-wrap-around t)
  #+end_src

  Opens the current buffer in an external program, bound to C-c o

  #+begin_src emacs-lisp
    (defun open-with ()
      "Simple function that allows us to open the underlying
        file of a buffer in an external program."
      (interactive)
      (when buffer-file-name
        (shell-command (concat
                        (if (eq system-type 'darwin)
                            "open"
                          (read-shell-command "Open current file with: "))
                        " "
                        buffer-file-name))))
    
    (global-set-key (kbd "C-c o") 'open-with)
  #+end_src

  Renames the current buffer, and its file. Bound to C-c r

  #+begin_src emacs-lisp
    (defun rename-file-and-buffer ()
      "Rename the current buffer and file it is visiting."
      (interactive)
      (let ((filename (buffer-file-name)))
        (if (not (and filename (file-exists-p filename)))
            (message "Buffer is not visiting a file!")
          (let ((new-name (read-file-name "New name: " filename)))
            (cond
             ((vc-backend filename) (vc-rename-file filename new-name))
             (t
              (rename-file filename new-name t)
              (rename-buffer new-name)
              (set-visited-file-name new-name)
              (set-buffer-modified-p nil)))))))
    
    (global-set-key (kbd "C-c r")  'rename-file-and-buffer)
  #+end_src

  Mouse navigation of buffers hack

  #+begin_src emacs-lisp
    (global-set-key (kbd "<C-S-iso-lefttab>") 'previous-buffer)
    (global-set-key (kbd "<C-tab>") 'next-buffer)
  #+end_src

  Switching to other buffers via shortcuts, like Conkeror. M-n and M-p
  is for user buffers and C-S-PageUp and C-S-PageDown is for Emacs buffers.

  #+begin_src emacs-lisp
    (defun next-user-buffer ()
      "Switch to the next user buffer.
        User buffers are those whose name does not start with *."
      (interactive)
      (next-buffer)
      (let ((i 0))
        (while (and (string-match "^*" (buffer-name)) (< i 50))
          (setq i (1+ i)) (next-buffer) )))
    
    (defun previous-user-buffer ()
      "Switch to the previous user buffer.
        User buffers are those whose name does not start with *."
      (interactive)
      (previous-buffer)
      (let ((i 0))
        (while (and (string-match "^*" (buffer-name)) (< i 50))
          (setq i (1+ i)) (previous-buffer) )))
    
    (defun next-emacs-buffer ()
      "Switch to the next emacs buffer.
        Emacs buffers are those whose name starts with *."
      (interactive)
      (next-buffer)
      (let ((i 0))
        (while (and (not (string-match "^*" (buffer-name))) (< i 50))
          (setq i (1+ i)) (next-buffer) )))
    
    (defun previous-emacs-buffer ()
      "Switch to the previous emacs buffer.
        Emacs buffers are those whose name starts with *."
      (interactive)
      (previous-buffer)
      (let ((i 0))
        (while (and (not (string-match "^*" (buffer-name))) (< i 50))
          (setq i (1+ i)) (previous-buffer) )))
    
  #+end_src

* The WWW

  #+begin_src emacs-lisp
    (if (string-equal system-type "gnu/linux") 
        (setq browse-url-browser-function 'browse-url-generic
              browse-url-generic-program "/home/ess/bin/conkeror.sh"))
  #+end_src

* Evil

  Set it up!

  #+begin_src emacs-lisp
    (require 'evil)
    (require 'evil-leader)
    (global-evil-leader-mode)
    (evil-mode t)
  #+end_src
  
  I want to be in Emacs mode when in insert mode.

  #+begin_src emacs-lisp
    (setcdr evil-insert-state-map nil)
    (define-key evil-insert-state-map
    (read-kbd-macro evil-toggle-key) 'evil-emacs-state)
    
    (define-key evil-insert-state-map [escape] 'evil-normal-state)
  #+end_src

  We want to enter Normal mode when pressing jj rapidly.

  #+begin_src emacs-lisp
    (require 'key-chord)
    (key-chord-define evil-insert-state-map "jj" 'evil-normal-state)
    (key-chord-mode 1)
  #+end_src

  We should go down by visual lines, not logical lines

  #+begin_src emacs-lisp
    (define-key evil-normal-state-map (kbd "j") 'evil-next-visual-line)
    (define-key evil-normal-state-map (kbd "k") 'evil-previous-visual-line)
  #+end_src

  C-s to insert snippets

  #+begin_src emacs-lisp
    (define-key evil-normal-state-map (kbd "C-c s") 'yas-insert-snippet)
    (define-key evil-insert-state-map (kbd "C-c s") 'yas-insert-snippet)
  #+end_src

  Ace jump to word when pressing space

  #+begin_src emacs-lisp
    (define-key evil-normal-state-map (kbd "SPC") 'ace-jump-word-mode)
  #+end_src

  Leader key (,) stuff

  - f :: Find file
  - b :: Switch buffer
  - k :: Kill buffer

  #+begin_src emacs-lisp
    (evil-leader/set-leader "ö")
    (evil-leader/set-key
      "f" 'find-file
      "b" 'switch-to-buffer
      "k" 'kill-this-buffer)
  #+end_src
* Global shortcuts

  Here's the keys that are defined in all modes.

  #+begin_src emacs-lisp
    (global-set-key (kbd "M-j")
                    (lambda ()
                      (interactive)
                      (join-line -1)))

    (global-set-key (kbd "C-c e") 'eval-and-replace)

    (require 'expand-region)
    (global-set-key (kbd "C-0") 'er/expand-region)
    (global-set-key (kbd "C-9") 'mc/mark-next-like-this)
    (global-set-key (kbd "C-8") 'mc/mark-all-like-this)

    (global-set-key (kbd "M-x") 'smex)
    (global-set-key (kbd "M-X") 'smex-major-mode-commands)
    (global-set-key "\M-n" 'next-user-buffer)
    (global-set-key "\M-p" 'previous-user-buffer)
    (global-set-key (kbd "<C-prior>") 'previous-emacs-buffer) ; Ctrl+Shift+PageUp
    (global-set-key (kbd "<C-next>") 'next-emacs-buffer) ; Ctrl+Shift+PageDown
    (global-set-key (kbd "C-c u") 'browse-url)

    ;; f1 = help
    ;; f2 = ??
    ;; f3 = Record macro
    ;; f4 = End or call macro
    ;; f10 = menu
    ;; f12 = console (i3)

    (global-set-key [f5] (lambda () (interactive) (find-file "~/org/gtd.txt")))
    (global-set-key [f6] 'magit-status)
    (global-set-key [f7] 'other-window)
    (global-set-key [f9] 'deft)
    ;; (global-set-key (kbd "½") "~")
  #+end_src
